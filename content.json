{"meta":{"title":"Vinci","subtitle":"热爱技术 热爱分享","description":"","author":"Vinci","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Leetcode #1 两数之和","slug":"Leetcode #1 两数之和","date":"2020-08-20T02:40:08.838Z","updated":"2020-08-20T02:40:08.844Z","comments":true,"path":"2020/08/20/Leetcode #1 两数之和/","link":"","permalink":"http://yoursite.com/2020/08/20/Leetcode%20#1%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"Leetcode #1 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。示例： 给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解法一：暴力法暴力法很简单，遍历每个元素 x，并查找是否存在一个值与 target - x 相等的目标元素。 123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = i + 1; j &lt; nums.length; j++) &#123; if (nums[j] == target - nums[i]) &#123; return new int[] &#123; i, j &#125;; &#125; &#125; &#125; throw new IllegalArgumentException(\"No two sum solution\"); &#125;&#125; 复杂度分析 时间复杂度：O(n^2)对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n)的时间。因此时间复杂度为 O(n^2)。 空间复杂度：O(1)。 解法二：两遍哈希表为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。 通过以空间换取速度的方式，我们可以将查找时间从 O(n) 降低到 O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。 一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！ 123456789101112131415class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; map.put(nums[i], i); &#125; for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123; return new int[] &#123; i, map.get(complement) &#125;; &#125; &#125; throw new IllegalArgumentException(\"No two sum solution\"); &#125;&#125; 复杂度分析 时间复杂度：O(n)，我们把包含有 n 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1)，所以时间复杂度为 O(n)。 空间复杂度O（n）所需的额外空间取决于哈希表中存储元素的数量，该表中存储了n个元素。 作者：LeetCode链接：https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/来源：力扣（LeetCode）","categories":[],"tags":[]},{"title":"Servlet初步使用","slug":"Servlet初步使用","date":"2020-07-19T08:30:22.431Z","updated":"2020-07-19T08:30:22.431Z","comments":true,"path":"2020/07/19/Servlet初步使用/","link":"","permalink":"http://yoursite.com/2020/07/19/Servlet%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Servlet初步使用 开发一个servlet需要如下几个步骤 创建web应用项目 编写servlet代码 部署到tomcat中 初次使用IDEA结合独立的tomcat 在WEB-INF目录下添加classes目录与lib目录 从ProjectStructure→Modules→Paths中修改两个路径，全部修改为所建立的classes目录 写好初步的Class后要点击项目右键 BuildMoudle 确保所建立classes中有所写类的.class文件 然后修改tomcat/conf/server.xml文件 添加 指向所写好的web目录 重启 tomcat 输入http://127.0.0.1/hello即可访问","categories":[],"tags":[]},{"title":"first blog","slug":"first blog","date":"2020-07-17T05:50:39.667Z","updated":"2020-07-17T05:54:20.799Z","comments":true,"path":"2020/07/17/first blog/","link":"","permalink":"http://yoursite.com/2020/07/17/first%20blog/","excerpt":"","text":"hexo博客使用初体验经过大概两个小事左右的查阅资料与尝试，终于有了自己的博客，谨此纪念。目前功能尚未完善，日后会增加完善。","categories":[],"tags":[]}],"categories":[],"tags":[]}